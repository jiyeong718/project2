{"ast":null,"code":"//오류\n// import React, { useState, useEffect } from 'react';\n// import groupListData from './groupListData'; // 정적 데이터 파일 import\n//\n// const App = () => {\n//   const [selectedOptions, setSelectedOptions] = useState([]);\n//   const [isGroupEnabled, setIsGroupEnabled] = useState(Array(groupListData.groupList.length).fill(false));\n//   const [optionList, setOptionList] = useState([]);\n//\n//   // 정적 데이터로서의 품목 그룹 리스트\n//   const groupList = groupListData.groupList;\n//   const countList = groupListData.countList;\n//\n//   // 각 그룹의 옵션을 선택할 때 처리 함수\n//   const handleGroupChange = (event, groupIndex) => {\n//     const selectedOption = optionList[groupIndex].find(option => option.value === event.target.value);\n//     const updatedOptions = [...selectedOptions];\n//     updatedOptions[groupIndex] = selectedOption;\n//     setSelectedOptions(updatedOptions);\n//\n//     // 현재 그룹 다음의 그룹을 enable\n//     if (groupIndex < groupList.length - 1) {\n//       const updatedIsGroupEnabled = [...isGroupEnabled];\n//       updatedIsGroupEnabled[groupIndex + 1] = true;\n//       setIsGroupEnabled(updatedIsGroupEnabled);\n//     }\n//   };\n//\n//   // 초기화 시 첫 번째 그룹 enable\n//   useEffect(() => {\n//     setIsGroupEnabled(updatedIsGroupEnabled => {\n//       const updated = [...updatedIsGroupEnabled];\n//       updated[0] = true;\n//       return updated;\n//     });\n//   }, []);\n//\n//   // 각 셀렉터의 옵션 설정\n//   useEffect(() => {\n//     const updatedOptionList = groupList.map((group, index) => {\n//       if (index === 0) {\n//         // 첫 번째 셀렉터의 옵션 설정\n//         return group.options.map(option => {\n//           const remainCount = countList.find(item => item.combination[0] === option)?.remainCount || 0;\n//           const label = remainCount === 0 ? `${option} (품절)` : option;\n//           return {\n//             value: option,\n//             label: label,\n//             isDisabled: remainCount === 0\n//           };\n//         });\n//       } else {\n//         const previousSelectedOption = selectedOptions[index - 1];\n//         if (previousSelectedOption) {\n//           // 중복된 조합을 필터링하여 하나의 옵션으로만 표시\n//           const currentGroupOptions = [];\n//           const seen = new Set();\n//           countList.forEach(item => {\n//             if (item.combination[index] && item.combination[index - 1] === previousSelectedOption.value && !seen.has(item.combination[index])) {\n//               const label = item.remainCount === 0 ? `${item.combination[index]} (품절)` : `${item.combination[index]} (${item.remainCount} 개 남음)`;\n//               currentGroupOptions.push({\n//                 value: item.combination[index],\n//                 label: label,\n//                 isDisabled: item.remainCount === 0\n//               });\n//               seen.add(item.combination[index]);\n//             }\n//           });\n//           return currentGroupOptions;\n//         } else {\n//           return [];\n//         }\n//       }\n//     });\n//\n//     // 마지막 셀렉터의 모든 옵션을 선택 가능하도록 설정\n//     updatedOptionList[groupList.length - 1] = groupList[groupList.length - 1].options.map(option => ({\n//       value: option,\n//       label: option,\n//       isDisabled: false\n//     }));\n//\n//     setOptionList(updatedOptionList);\n//   }, [countList, groupList, selectedOptions]);\n//\n//   return (\n//     <div>\n//       {groupList.map((group, index) => (\n//         <div key={index}>\n//           <h2>{group.title}</h2>\n//           <select\n//             value={selectedOptions[index] ? selectedOptions[index].value : ''}\n//             onChange={(event) => handleGroupChange(event, index)}\n//             disabled={index === 0 ? false : !isGroupEnabled[index]}\n//           >\n//             <option value=\"\" disabled={true}>{group.title}</option>\n//             {optionList[index]?.map((option, idx) => (\n//               <option key={idx} value={option.value} disabled={option.isDisabled}>{option.label}</option>\n//             ))}\n//           </select>\n//         </div>\n//       ))}\n//       <h2>선택한 옵션:</h2>\n//       {selectedOptions.map((selectedOption, index) => (\n//         <p key={index}>\n//           {groupList[index]?.title}: {selectedOption ? selectedOption.label : '-'}\n//         </p>\n//       ))}\n//     </div>\n//   );\n// };\n//\n// export default App;\n\n// 두번째가 문제\n// import React, { useState, useEffect } from 'react';\n// import groupListData from './groupListData'; // 정적 데이터 파일 import\n//\n// const App = () => {\n//   const [selectedOptions, setSelectedOptions] = useState([]);\n//   const [isGroupEnabled, setIsGroupEnabled] = useState(Array(groupListData.groupList.length).fill(false));\n//   const [optionList, setOptionList] = useState([]);\n//\n//   // 정적 데이터로서의 품목 그룹 리스트\n//   const groupList = groupListData.groupList;\n//   const countList = groupListData.countList;\n//\n//   // 각 그룹의 옵션을 선택할 때 처리 함수\n//   const handleGroupChange = (event, groupIndex) => {\n//     const selectedOption = optionList[groupIndex].find(option => option.value === event.target.value);\n//     const updatedOptions = [...selectedOptions];\n//     updatedOptions[groupIndex] = selectedOption;\n//     setSelectedOptions(updatedOptions);\n//\n//     // 현재 그룹 다음의 그룹을 enable\n//     if (groupIndex < groupList.length - 1) {\n//       const updatedIsGroupEnabled = [...isGroupEnabled];\n//       updatedIsGroupEnabled[groupIndex + 1] = true;\n//       setIsGroupEnabled(updatedIsGroupEnabled);\n//     }\n//   };\n//\n//   // 초기화 시 첫 번째 그룹 enable\n//   useEffect(() => {\n//     setIsGroupEnabled(updatedIsGroupEnabled => {\n//       const updated = [...updatedIsGroupEnabled];\n//       updated[0] = true;\n//       return updated;\n//     });\n//   }, []);\n//\n//   // 각 셀렉터의 옵션 설정\n//   useEffect(() => {\n//     const updatedOptionList = groupList.map((group, index) => {\n//       if (index === 0) {\n//         return group.options.map(option => {\n//           // 해당 동물과 관련된 모든 과일의 조합을 반복하여 remainCount를 확인\n//           const hasAvailableOption = countList.some(item => item.combination[0] === option && item.remainCount !== 0);\n//           const label = hasAvailableOption ? option : `${option} (품절)`;\n//           return {\n//             value: option,\n//             label: label,\n//             isDisabled: !hasAvailableOption\n//           };\n//         });\n//       } else if (index === 1 && selectedOptions[0]) {\n//         // 두 번째 셀렉터의 옵션 설정\n//         const previousSelectedOption = selectedOptions[index - 1];\n//         return group.options.map(option => {\n//           const hasAvailableOption = countList.some(item => item.combination[0] === previousSelectedOption.value && item.combination[1] === option && item.remainCount !== 0);\n//           const label = hasAvailableOption ? option : `${option} (품절)`;\n//           return {\n//             value: option,\n//             label: label,\n//             isDisabled: !hasAvailableOption\n//           };\n//         });\n//       } else {\n//         const previousSelectedOption = selectedOptions[index - 1];\n//         if (previousSelectedOption) {\n//           // 중복된 조합을 필터링하여 하나의 옵션으로만 표시\n//           const currentGroupOptions = [];\n//           const seen = new Set();\n//           countList.forEach(item => {\n//             if (item.combination[index] && item.combination[index - 1] === previousSelectedOption.value && !seen.has(item.combination[index])) {\n//               const label = item.remainCount === 0 ? `${item.combination[index]} (품절)` : `${item.combination[index]} (${item.remainCount} 개 남음)`;\n//               currentGroupOptions.push({\n//                 value: item.combination[index],\n//                 label: label,\n//                 isDisabled: item.remainCount === 0\n//               });\n//               seen.add(item.combination[index]);\n//             }\n//           });\n//           return currentGroupOptions;\n//         } else {\n//           return [];\n//         }\n//       }\n//     });\n//\n//     // 마지막 셀렉터의 모든 옵션을 선택 가능하도록 설정\n//     updatedOptionList[groupList.length - 1] = groupList[groupList.length - 1].options.map(option => ({\n//       value: option,\n//       label: option,\n//       isDisabled: false\n//     }));\n//\n//     setOptionList(updatedOptionList);\n//   }, [countList, groupList, selectedOptions]);\n//\n//   return (\n//     <div>\n//       {groupList.map((group, index) => (\n//         <div key={index}>\n//           <h2>{group.title}</h2>\n//           <select\n//             value={selectedOptions[index] ? selectedOptions[index].value : ''}\n//             onChange={(event) => handleGroupChange(event, index)}\n//             disabled={index === 0 ? false : !isGroupEnabled[index]}\n//           >\n//             <option value=\"\" disabled={true}>{group.title}</option>\n//             {optionList[index]?.map((option, idx) => (\n//               <option key={idx} value={option.value} disabled={option.isDisabled}>{option.label}</option>\n//             ))}\n//           </select>\n//         </div>\n//       ))}\n//       <h2>선택한 옵션:</h2>\n//       {selectedOptions.map((selectedOption, index) => (\n//         <p key={index}>\n//           {groupList[index]?.title}: {selectedOption ? selectedOption.label : '-'}\n//         </p>\n//       ))}\n//     </div>\n//   );\n// };\n//\n// export default App;\n\n//마지막 셀렉터가 문제\n// import React, { useState, useEffect } from 'react';\n// import groupListData from './groupListData'; // 정적 데이터 파일 import\n//\n// const App = () => {\n//   const [selectedOptions, setSelectedOptions] = useState([]);\n//   const [isGroupEnabled, setIsGroupEnabled] = useState(Array(groupListData.groupList.length).fill(false));\n//   const [optionList, setOptionList] = useState([]);\n//\n//   // 정적 데이터로서의 품목 그룹 리스트\n//   const groupList = groupListData.groupList;\n//   const countList = groupListData.countList;\n//\n//   // 각 그룹의 옵션을 선택할 때 처리 함수\n//   const handleGroupChange = (event, groupIndex) => {\n//     const selectedOption = optionList[groupIndex].find(option => option.value === event.target.value);\n//     const updatedOptions = [...selectedOptions];\n//     updatedOptions[groupIndex] = selectedOption;\n//     setSelectedOptions(updatedOptions);\n//\n//     // 현재 그룹 다음의 그룹을 enable\n//     if (groupIndex < groupList.length - 1) {\n//       const updatedIsGroupEnabled = [...isGroupEnabled];\n//       updatedIsGroupEnabled[groupIndex + 1] = true;\n//       setIsGroupEnabled(updatedIsGroupEnabled);\n//     }\n//   };\n//\n//   // 초기화 시 첫 번째 그룹 enable\n//   useEffect(() => {\n//     setIsGroupEnabled(updatedIsGroupEnabled => {\n//       const updated = [...updatedIsGroupEnabled];\n//       updated[0] = true;\n//       return updated;\n//     });\n//   }, []);\n//\n//   // 각 셀렉터의 옵션 설정\n//   useEffect(() => {\n//     const updatedOptionList = groupList.map((group, index) => {\n//       if (index === 0) {\n//         // 첫 번째 셀렉터의 옵션 설정\n//         return group.options.map(option => {\n//           // 해당 동물과 관련된 모든 과일의 조합을 반복하여 remainCount를 확인\n//           const hasAvailableOption = countList.some(item => item.combination[0] === option && item.remainCount !== 0);\n//           const label = hasAvailableOption ? option : `${option} (품절)`;\n//           return {\n//             value: option,\n//             label: label,\n//             isDisabled: !hasAvailableOption\n//           };\n//         });\n//       } else if (index > 0 && selectedOptions[index - 1]) {\n//         // 이전 셀렉터의 선택 옵션과 현재 그룹의 옵션 조합에 따라 remainCount를 확인하여 품절 여부를 설정\n//         const previousSelectedOption = selectedOptions[index - 1];\n//         return group.options.map(option => {\n//           const hasAvailableOption = countList.some(item =>\n//             item.combination[index - 1] === previousSelectedOption.value &&\n//             item.combination[index] === option &&\n//             item.remainCount !== 0\n//           );\n//           const label = hasAvailableOption ? option : `${option} (품절)`;\n//           return {\n//             value: option,\n//             label: label,\n//             isDisabled: !hasAvailableOption\n//           };\n//         });\n//       } else {\n//         return [];\n//       }\n//     });\n//\n//     // 마지막 셀렉터의 모든 옵션을 선택 가능하도록 설정\n//     // updatedOptionList[groupList.length - 1] = groupList[groupList.length - 1].options.map(option => ({\n//     //   value: option,\n//     //   label: option,\n//     //   isDisabled: false\n//     // }));\n//\n//     setOptionList(updatedOptionList);\n//   }, [countList, groupList, selectedOptions]);\n//\n//   return (\n//     <div>\n//       {groupList.map((group, index) => (\n//         <div key={index}>\n//           <h2>{group.title}</h2>\n//           <select\n//             value={selectedOptions[index] ? selectedOptions[index].value : ''}\n//             onChange={(event) => handleGroupChange(event, index)}\n//             disabled={index === 0 ? false : !isGroupEnabled[index]}\n//           >\n//             <option value=\"\" disabled={true}>{group.title}</option>\n//             {optionList[index]?.map((option, idx) => (\n//               <option key={idx} value={option.value} disabled={option.isDisabled}>{option.label}</option>\n//             ))}\n//           </select>\n//         </div>\n//       ))}\n//       <h2>선택한 옵션:</h2>\n//       {selectedOptions.map((selectedOption, index) => (\n//         <p key={index}>\n//           {groupList[index]?.title}: {selectedOption ? selectedOption.label : '-'}\n//         </p>\n//       ))}\n//     </div>\n//   );\n// };\n//\n// export default App;","map":{"version":3,"names":[],"sources":["/Users/jiyeong/WebstormProjects/test2/src/App.js"],"sourcesContent":["//오류\n// import React, { useState, useEffect } from 'react';\n// import groupListData from './groupListData'; // 정적 데이터 파일 import\n//\n// const App = () => {\n//   const [selectedOptions, setSelectedOptions] = useState([]);\n//   const [isGroupEnabled, setIsGroupEnabled] = useState(Array(groupListData.groupList.length).fill(false));\n//   const [optionList, setOptionList] = useState([]);\n//\n//   // 정적 데이터로서의 품목 그룹 리스트\n//   const groupList = groupListData.groupList;\n//   const countList = groupListData.countList;\n//\n//   // 각 그룹의 옵션을 선택할 때 처리 함수\n//   const handleGroupChange = (event, groupIndex) => {\n//     const selectedOption = optionList[groupIndex].find(option => option.value === event.target.value);\n//     const updatedOptions = [...selectedOptions];\n//     updatedOptions[groupIndex] = selectedOption;\n//     setSelectedOptions(updatedOptions);\n//\n//     // 현재 그룹 다음의 그룹을 enable\n//     if (groupIndex < groupList.length - 1) {\n//       const updatedIsGroupEnabled = [...isGroupEnabled];\n//       updatedIsGroupEnabled[groupIndex + 1] = true;\n//       setIsGroupEnabled(updatedIsGroupEnabled);\n//     }\n//   };\n//\n//   // 초기화 시 첫 번째 그룹 enable\n//   useEffect(() => {\n//     setIsGroupEnabled(updatedIsGroupEnabled => {\n//       const updated = [...updatedIsGroupEnabled];\n//       updated[0] = true;\n//       return updated;\n//     });\n//   }, []);\n//\n//   // 각 셀렉터의 옵션 설정\n//   useEffect(() => {\n//     const updatedOptionList = groupList.map((group, index) => {\n//       if (index === 0) {\n//         // 첫 번째 셀렉터의 옵션 설정\n//         return group.options.map(option => {\n//           const remainCount = countList.find(item => item.combination[0] === option)?.remainCount || 0;\n//           const label = remainCount === 0 ? `${option} (품절)` : option;\n//           return {\n//             value: option,\n//             label: label,\n//             isDisabled: remainCount === 0\n//           };\n//         });\n//       } else {\n//         const previousSelectedOption = selectedOptions[index - 1];\n//         if (previousSelectedOption) {\n//           // 중복된 조합을 필터링하여 하나의 옵션으로만 표시\n//           const currentGroupOptions = [];\n//           const seen = new Set();\n//           countList.forEach(item => {\n//             if (item.combination[index] && item.combination[index - 1] === previousSelectedOption.value && !seen.has(item.combination[index])) {\n//               const label = item.remainCount === 0 ? `${item.combination[index]} (품절)` : `${item.combination[index]} (${item.remainCount} 개 남음)`;\n//               currentGroupOptions.push({\n//                 value: item.combination[index],\n//                 label: label,\n//                 isDisabled: item.remainCount === 0\n//               });\n//               seen.add(item.combination[index]);\n//             }\n//           });\n//           return currentGroupOptions;\n//         } else {\n//           return [];\n//         }\n//       }\n//     });\n//\n//     // 마지막 셀렉터의 모든 옵션을 선택 가능하도록 설정\n//     updatedOptionList[groupList.length - 1] = groupList[groupList.length - 1].options.map(option => ({\n//       value: option,\n//       label: option,\n//       isDisabled: false\n//     }));\n//\n//     setOptionList(updatedOptionList);\n//   }, [countList, groupList, selectedOptions]);\n//\n//   return (\n//     <div>\n//       {groupList.map((group, index) => (\n//         <div key={index}>\n//           <h2>{group.title}</h2>\n//           <select\n//             value={selectedOptions[index] ? selectedOptions[index].value : ''}\n//             onChange={(event) => handleGroupChange(event, index)}\n//             disabled={index === 0 ? false : !isGroupEnabled[index]}\n//           >\n//             <option value=\"\" disabled={true}>{group.title}</option>\n//             {optionList[index]?.map((option, idx) => (\n//               <option key={idx} value={option.value} disabled={option.isDisabled}>{option.label}</option>\n//             ))}\n//           </select>\n//         </div>\n//       ))}\n//       <h2>선택한 옵션:</h2>\n//       {selectedOptions.map((selectedOption, index) => (\n//         <p key={index}>\n//           {groupList[index]?.title}: {selectedOption ? selectedOption.label : '-'}\n//         </p>\n//       ))}\n//     </div>\n//   );\n// };\n//\n// export default App;\n\n// 두번째가 문제\n// import React, { useState, useEffect } from 'react';\n// import groupListData from './groupListData'; // 정적 데이터 파일 import\n//\n// const App = () => {\n//   const [selectedOptions, setSelectedOptions] = useState([]);\n//   const [isGroupEnabled, setIsGroupEnabled] = useState(Array(groupListData.groupList.length).fill(false));\n//   const [optionList, setOptionList] = useState([]);\n//\n//   // 정적 데이터로서의 품목 그룹 리스트\n//   const groupList = groupListData.groupList;\n//   const countList = groupListData.countList;\n//\n//   // 각 그룹의 옵션을 선택할 때 처리 함수\n//   const handleGroupChange = (event, groupIndex) => {\n//     const selectedOption = optionList[groupIndex].find(option => option.value === event.target.value);\n//     const updatedOptions = [...selectedOptions];\n//     updatedOptions[groupIndex] = selectedOption;\n//     setSelectedOptions(updatedOptions);\n//\n//     // 현재 그룹 다음의 그룹을 enable\n//     if (groupIndex < groupList.length - 1) {\n//       const updatedIsGroupEnabled = [...isGroupEnabled];\n//       updatedIsGroupEnabled[groupIndex + 1] = true;\n//       setIsGroupEnabled(updatedIsGroupEnabled);\n//     }\n//   };\n//\n//   // 초기화 시 첫 번째 그룹 enable\n//   useEffect(() => {\n//     setIsGroupEnabled(updatedIsGroupEnabled => {\n//       const updated = [...updatedIsGroupEnabled];\n//       updated[0] = true;\n//       return updated;\n//     });\n//   }, []);\n//\n//   // 각 셀렉터의 옵션 설정\n//   useEffect(() => {\n//     const updatedOptionList = groupList.map((group, index) => {\n//       if (index === 0) {\n//         return group.options.map(option => {\n//           // 해당 동물과 관련된 모든 과일의 조합을 반복하여 remainCount를 확인\n//           const hasAvailableOption = countList.some(item => item.combination[0] === option && item.remainCount !== 0);\n//           const label = hasAvailableOption ? option : `${option} (품절)`;\n//           return {\n//             value: option,\n//             label: label,\n//             isDisabled: !hasAvailableOption\n//           };\n//         });\n//       } else if (index === 1 && selectedOptions[0]) {\n//         // 두 번째 셀렉터의 옵션 설정\n//         const previousSelectedOption = selectedOptions[index - 1];\n//         return group.options.map(option => {\n//           const hasAvailableOption = countList.some(item => item.combination[0] === previousSelectedOption.value && item.combination[1] === option && item.remainCount !== 0);\n//           const label = hasAvailableOption ? option : `${option} (품절)`;\n//           return {\n//             value: option,\n//             label: label,\n//             isDisabled: !hasAvailableOption\n//           };\n//         });\n//       } else {\n//         const previousSelectedOption = selectedOptions[index - 1];\n//         if (previousSelectedOption) {\n//           // 중복된 조합을 필터링하여 하나의 옵션으로만 표시\n//           const currentGroupOptions = [];\n//           const seen = new Set();\n//           countList.forEach(item => {\n//             if (item.combination[index] && item.combination[index - 1] === previousSelectedOption.value && !seen.has(item.combination[index])) {\n//               const label = item.remainCount === 0 ? `${item.combination[index]} (품절)` : `${item.combination[index]} (${item.remainCount} 개 남음)`;\n//               currentGroupOptions.push({\n//                 value: item.combination[index],\n//                 label: label,\n//                 isDisabled: item.remainCount === 0\n//               });\n//               seen.add(item.combination[index]);\n//             }\n//           });\n//           return currentGroupOptions;\n//         } else {\n//           return [];\n//         }\n//       }\n//     });\n//\n//     // 마지막 셀렉터의 모든 옵션을 선택 가능하도록 설정\n//     updatedOptionList[groupList.length - 1] = groupList[groupList.length - 1].options.map(option => ({\n//       value: option,\n//       label: option,\n//       isDisabled: false\n//     }));\n//\n//     setOptionList(updatedOptionList);\n//   }, [countList, groupList, selectedOptions]);\n//\n//   return (\n//     <div>\n//       {groupList.map((group, index) => (\n//         <div key={index}>\n//           <h2>{group.title}</h2>\n//           <select\n//             value={selectedOptions[index] ? selectedOptions[index].value : ''}\n//             onChange={(event) => handleGroupChange(event, index)}\n//             disabled={index === 0 ? false : !isGroupEnabled[index]}\n//           >\n//             <option value=\"\" disabled={true}>{group.title}</option>\n//             {optionList[index]?.map((option, idx) => (\n//               <option key={idx} value={option.value} disabled={option.isDisabled}>{option.label}</option>\n//             ))}\n//           </select>\n//         </div>\n//       ))}\n//       <h2>선택한 옵션:</h2>\n//       {selectedOptions.map((selectedOption, index) => (\n//         <p key={index}>\n//           {groupList[index]?.title}: {selectedOption ? selectedOption.label : '-'}\n//         </p>\n//       ))}\n//     </div>\n//   );\n// };\n//\n// export default App;\n\n//마지막 셀렉터가 문제\n// import React, { useState, useEffect } from 'react';\n// import groupListData from './groupListData'; // 정적 데이터 파일 import\n//\n// const App = () => {\n//   const [selectedOptions, setSelectedOptions] = useState([]);\n//   const [isGroupEnabled, setIsGroupEnabled] = useState(Array(groupListData.groupList.length).fill(false));\n//   const [optionList, setOptionList] = useState([]);\n//\n//   // 정적 데이터로서의 품목 그룹 리스트\n//   const groupList = groupListData.groupList;\n//   const countList = groupListData.countList;\n//\n//   // 각 그룹의 옵션을 선택할 때 처리 함수\n//   const handleGroupChange = (event, groupIndex) => {\n//     const selectedOption = optionList[groupIndex].find(option => option.value === event.target.value);\n//     const updatedOptions = [...selectedOptions];\n//     updatedOptions[groupIndex] = selectedOption;\n//     setSelectedOptions(updatedOptions);\n//\n//     // 현재 그룹 다음의 그룹을 enable\n//     if (groupIndex < groupList.length - 1) {\n//       const updatedIsGroupEnabled = [...isGroupEnabled];\n//       updatedIsGroupEnabled[groupIndex + 1] = true;\n//       setIsGroupEnabled(updatedIsGroupEnabled);\n//     }\n//   };\n//\n//   // 초기화 시 첫 번째 그룹 enable\n//   useEffect(() => {\n//     setIsGroupEnabled(updatedIsGroupEnabled => {\n//       const updated = [...updatedIsGroupEnabled];\n//       updated[0] = true;\n//       return updated;\n//     });\n//   }, []);\n//\n//   // 각 셀렉터의 옵션 설정\n//   useEffect(() => {\n//     const updatedOptionList = groupList.map((group, index) => {\n//       if (index === 0) {\n//         // 첫 번째 셀렉터의 옵션 설정\n//         return group.options.map(option => {\n//           // 해당 동물과 관련된 모든 과일의 조합을 반복하여 remainCount를 확인\n//           const hasAvailableOption = countList.some(item => item.combination[0] === option && item.remainCount !== 0);\n//           const label = hasAvailableOption ? option : `${option} (품절)`;\n//           return {\n//             value: option,\n//             label: label,\n//             isDisabled: !hasAvailableOption\n//           };\n//         });\n//       } else if (index > 0 && selectedOptions[index - 1]) {\n//         // 이전 셀렉터의 선택 옵션과 현재 그룹의 옵션 조합에 따라 remainCount를 확인하여 품절 여부를 설정\n//         const previousSelectedOption = selectedOptions[index - 1];\n//         return group.options.map(option => {\n//           const hasAvailableOption = countList.some(item =>\n//             item.combination[index - 1] === previousSelectedOption.value &&\n//             item.combination[index] === option &&\n//             item.remainCount !== 0\n//           );\n//           const label = hasAvailableOption ? option : `${option} (품절)`;\n//           return {\n//             value: option,\n//             label: label,\n//             isDisabled: !hasAvailableOption\n//           };\n//         });\n//       } else {\n//         return [];\n//       }\n//     });\n//\n//     // 마지막 셀렉터의 모든 옵션을 선택 가능하도록 설정\n//     // updatedOptionList[groupList.length - 1] = groupList[groupList.length - 1].options.map(option => ({\n//     //   value: option,\n//     //   label: option,\n//     //   isDisabled: false\n//     // }));\n//\n//     setOptionList(updatedOptionList);\n//   }, [countList, groupList, selectedOptions]);\n//\n//   return (\n//     <div>\n//       {groupList.map((group, index) => (\n//         <div key={index}>\n//           <h2>{group.title}</h2>\n//           <select\n//             value={selectedOptions[index] ? selectedOptions[index].value : ''}\n//             onChange={(event) => handleGroupChange(event, index)}\n//             disabled={index === 0 ? false : !isGroupEnabled[index]}\n//           >\n//             <option value=\"\" disabled={true}>{group.title}</option>\n//             {optionList[index]?.map((option, idx) => (\n//               <option key={idx} value={option.value} disabled={option.isDisabled}>{option.label}</option>\n//             ))}\n//           </select>\n//         </div>\n//       ))}\n//       <h2>선택한 옵션:</h2>\n//       {selectedOptions.map((selectedOption, index) => (\n//         <p key={index}>\n//           {groupList[index]?.title}: {selectedOption ? selectedOption.label : '-'}\n//         </p>\n//       ))}\n//     </div>\n//   );\n// };\n//\n// export default App;\n\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}