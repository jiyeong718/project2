{"ast":null,"code":"// 첫번째 셀렉터에도 적용이 안됨.\n// import React, { useState, useEffect } from 'react';\n// import Select from 'react-select';\n// import groupListData from './groupListData'; // 정적 데이터 파일 import\n//\n// const App = () => {\n//   const [selectedOptions, setSelectedOptions] = useState([]);\n//   const [isGroupEnabled, setIsGroupEnabled] = useState(Array(groupListData.groupList.length).fill(false));\n//   const [optionList, setOptionList] = useState([]);\n//\n//   // 정적 데이터로서의 품목 그룹 리스트\n//   const groupList = groupListData.groupList;\n//   const countList = groupListData.countList;\n//\n//   // 각 그룹의 옵션을 선택할 때 처리 함수\n//   const handleGroupChange = (selectedOption, groupIndex) => {\n//     const updatedOptions = [...selectedOptions];\n//     updatedOptions[groupIndex] = selectedOption;\n//     setSelectedOptions(updatedOptions);\n//\n//     // 현재 그룹 다음의 그룹을 enable\n//     if (groupIndex < groupList.length - 1) {\n//       const updatedIsGroupEnabled = [...isGroupEnabled];\n//       updatedIsGroupEnabled[groupIndex + 1] = true;\n//       setIsGroupEnabled(updatedIsGroupEnabled);\n//     }\n//   };\n//\n//   // 초기화 시 첫 번째 그룹 enable\n//   useEffect(() => {\n//     setIsGroupEnabled(updatedIsGroupEnabled => {\n//       const updated = [...updatedIsGroupEnabled];\n//       updated[0] = true;\n//       return updated;\n//     });\n//   }, []);\n//\n//   // 각 셀렉터의 옵션 설정\n//   useEffect(() => {\n//     const updatedOptionList = groupList.map((group, index) => {\n//       if (index === 0) {\n//         return group.options.map(option => ({\n//           value: option,\n//           label: option,\n//           isDisabled: false\n//         }));\n//       } else {\n//         const previousSelectedOption = selectedOptions[index - 1];\n//         if (previousSelectedOption) {\n//           // 중복된 조합을 필터링하여 하나의 옵션으로만 표시\n//           const currentGroupOptions = [];\n//           const seen = new Set();\n//           countList.forEach(item => {\n//             if (item.combination[index] && item.combination[index - 1] === previousSelectedOption.value && !seen.has(item.combination[index])) {\n//               const label = item.remainCount === 0 ? `${item.combination[index]} (품절)` : `${item.combination[index]} (${item.remainCount} 개 남음)`;\n//               currentGroupOptions.push({\n//                 value: item.combination[index],\n//                 label: label,\n//                 isDisabled: item.remainCount === 0\n//               });\n//               seen.add(item.combination[index]);\n//             }\n//           });\n//           return currentGroupOptions;\n//         } else {\n//           return [];\n//         }\n//       }\n//     });\n//\n//     // 마지막 셀렉터의 모든 옵션을 선택 가능하도록 설정\n//     updatedOptionList[groupList.length - 1] = groupList[groupList.length - 1].options.map(option => ({\n//       value: option,\n//       label: option,\n//       isDisabled: false\n//     }));\n//\n//     setOptionList(updatedOptionList);\n//   }, [countList, groupList, selectedOptions]);\n//\n//   return (\n//     <div>\n//       {groupList.map((group, index) => (\n//         <div key={index}>\n//           <h2>{group.title}</h2>\n//           <Select\n//             options={optionList[index]}\n//             onChange={(selectedOption) => handleGroupChange(selectedOption, index)}\n//             value={selectedOptions[index]}\n//             placeholder={group.title}\n//             isDisabled={index === 0 ? false : !isGroupEnabled[index]}\n//           />\n//         </div>\n//       ))}\n//       <h2>선택한 옵션:</h2>\n//       {selectedOptions.map((selectedOption, index) => (\n//         <p key={index}>\n//           {groupList[index].title}: {selectedOption ? selectedOption.label : '-'}\n//         </p>\n//       ))}\n//     </div>\n//   );\n// };\n//\n// export default App;\n\n// 첫번째 셀렉터에는 적용이 된 상태.\n// import React, { useState, useEffect } from 'react';\n// import Select from 'react-select';\n// import groupListData from './groupListData'; // 정적 데이터 파일 import\n//\n// const App = () => {\n//   const [selectedOptions, setSelectedOptions] = useState([]);\n//   const [isGroupEnabled, setIsGroupEnabled] = useState(Array(groupListData.groupList.length).fill(false));\n//   const [optionList, setOptionList] = useState([]);\n//\n//   // 정적 데이터로서의 품목 그룹 리스트\n//   const groupList = groupListData.groupList;\n//   const countList = groupListData.countList;\n//\n//   // 각 그룹의 옵션을 선택할 때 처리 함수\n//   const handleGroupChange = (selectedOption, groupIndex) => {\n//     const updatedOptions = [...selectedOptions];\n//     updatedOptions[groupIndex] = selectedOption;\n//     setSelectedOptions(updatedOptions);\n//\n//     // 현재 그룹 다음의 그룹을 enable\n//     if (groupIndex < groupList.length - 1) {\n//       const updatedIsGroupEnabled = [...isGroupEnabled];\n//       updatedIsGroupEnabled[groupIndex + 1] = true;\n//       setIsGroupEnabled(updatedIsGroupEnabled);\n//     }\n//   };\n//\n//   // 초기화 시 첫 번째 그룹만 enable\n//   useEffect(() => {\n//     setIsGroupEnabled(updatedIsGroupEnabled => {\n//       const updated = [...updatedIsGroupEnabled];\n//       updated[0] = true;\n//       return updated;\n//     });\n//   }, []);\n//\n//   // 각 셀렉터의 옵션 설정\n//   useEffect(() => {\n//     const updatedOptionList = groupList.map((group, index) => {\n//       if (index === 0) {\n//         return [{\n//           value: group.title,\n//           label: group.title,\n//           isDisabled: true // 처음에는 선택할 수 없도록 disable 처리\n//         }, ...group.options.map(option => ({\n//           value: option,\n//           label: option,\n//           isDisabled: false\n//         }))];\n//       } else {\n//         const previousSelectedOption = selectedOptions[index - 1];\n//         if (previousSelectedOption) {\n//           // 중복된 조합을 필터링하여 하나의 옵션으로만 표시\n//           const currentGroupOptions = [];\n//           const seen = new Set();\n//           countList.forEach(item => {\n//             if (item.combination[index] && item.combination[index - 1] === previousSelectedOption.value && !seen.has(item.combination[index])) {\n//               const label = item.remainCount === 0 ? `${item.combination[index]} (품절)` : `${item.combination[index]} (${item.remainCount} 개 남음)`;\n//               currentGroupOptions.push({\n//                 value: item.combination[index],\n//                 label: label,\n//                 isDisabled: item.remainCount === 0\n//               });\n//               seen.add(item.combination[index]);\n//             }\n//           });\n//           return currentGroupOptions;\n//         } else {\n//           return [];\n//         }\n//       }\n//     });\n//\n//     // 마지막 셀렉터의 모든 옵션을 선택 가능하도록 설정\n//     updatedOptionList[groupList.length - 1] = groupList[groupList.length - 1].options.map(option => ({\n//       value: option,\n//       label: option,\n//       isDisabled: false\n//     }));\n//\n//     setOptionList(updatedOptionList);\n//   }, [countList, groupList, selectedOptions]);\n//\n//   return (\n//     <div>\n//       {groupList.map((group, index) => (\n//         <div key={index}>\n//           <h2>{group.title}</h2>\n//           <Select\n//             options={optionList[index]}\n//             onChange={(selectedOption) => handleGroupChange(selectedOption, index)}\n//             value={selectedOptions[index]}\n//             placeholder={group.title}\n//             isDisabled={index === 0 ? false : !isGroupEnabled[index]} // 첫 번째 셀렉터는 선택할 수 없도록 처리\n//           />\n//         </div>\n//       ))}\n//       <h2>선택한 옵션:</h2>\n//       {selectedOptions.map((selectedOption, index) => (\n//         <p key={index}>\n//           {groupList[index].title}: {selectedOption ? selectedOption.label : '-'}\n//         </p>\n//       ))}\n//     </div>\n//   );\n// };\n//\n// export default App;\n\n//순수리엑트로만 셀렉트 박스 만들기","map":{"version":3,"names":[],"sources":["/Users/jiyeong/WebstormProjects/test2/src/App.js"],"sourcesContent":["// 첫번째 셀렉터에도 적용이 안됨.\n// import React, { useState, useEffect } from 'react';\n// import Select from 'react-select';\n// import groupListData from './groupListData'; // 정적 데이터 파일 import\n//\n// const App = () => {\n//   const [selectedOptions, setSelectedOptions] = useState([]);\n//   const [isGroupEnabled, setIsGroupEnabled] = useState(Array(groupListData.groupList.length).fill(false));\n//   const [optionList, setOptionList] = useState([]);\n//\n//   // 정적 데이터로서의 품목 그룹 리스트\n//   const groupList = groupListData.groupList;\n//   const countList = groupListData.countList;\n//\n//   // 각 그룹의 옵션을 선택할 때 처리 함수\n//   const handleGroupChange = (selectedOption, groupIndex) => {\n//     const updatedOptions = [...selectedOptions];\n//     updatedOptions[groupIndex] = selectedOption;\n//     setSelectedOptions(updatedOptions);\n//\n//     // 현재 그룹 다음의 그룹을 enable\n//     if (groupIndex < groupList.length - 1) {\n//       const updatedIsGroupEnabled = [...isGroupEnabled];\n//       updatedIsGroupEnabled[groupIndex + 1] = true;\n//       setIsGroupEnabled(updatedIsGroupEnabled);\n//     }\n//   };\n//\n//   // 초기화 시 첫 번째 그룹 enable\n//   useEffect(() => {\n//     setIsGroupEnabled(updatedIsGroupEnabled => {\n//       const updated = [...updatedIsGroupEnabled];\n//       updated[0] = true;\n//       return updated;\n//     });\n//   }, []);\n//\n//   // 각 셀렉터의 옵션 설정\n//   useEffect(() => {\n//     const updatedOptionList = groupList.map((group, index) => {\n//       if (index === 0) {\n//         return group.options.map(option => ({\n//           value: option,\n//           label: option,\n//           isDisabled: false\n//         }));\n//       } else {\n//         const previousSelectedOption = selectedOptions[index - 1];\n//         if (previousSelectedOption) {\n//           // 중복된 조합을 필터링하여 하나의 옵션으로만 표시\n//           const currentGroupOptions = [];\n//           const seen = new Set();\n//           countList.forEach(item => {\n//             if (item.combination[index] && item.combination[index - 1] === previousSelectedOption.value && !seen.has(item.combination[index])) {\n//               const label = item.remainCount === 0 ? `${item.combination[index]} (품절)` : `${item.combination[index]} (${item.remainCount} 개 남음)`;\n//               currentGroupOptions.push({\n//                 value: item.combination[index],\n//                 label: label,\n//                 isDisabled: item.remainCount === 0\n//               });\n//               seen.add(item.combination[index]);\n//             }\n//           });\n//           return currentGroupOptions;\n//         } else {\n//           return [];\n//         }\n//       }\n//     });\n//\n//     // 마지막 셀렉터의 모든 옵션을 선택 가능하도록 설정\n//     updatedOptionList[groupList.length - 1] = groupList[groupList.length - 1].options.map(option => ({\n//       value: option,\n//       label: option,\n//       isDisabled: false\n//     }));\n//\n//     setOptionList(updatedOptionList);\n//   }, [countList, groupList, selectedOptions]);\n//\n//   return (\n//     <div>\n//       {groupList.map((group, index) => (\n//         <div key={index}>\n//           <h2>{group.title}</h2>\n//           <Select\n//             options={optionList[index]}\n//             onChange={(selectedOption) => handleGroupChange(selectedOption, index)}\n//             value={selectedOptions[index]}\n//             placeholder={group.title}\n//             isDisabled={index === 0 ? false : !isGroupEnabled[index]}\n//           />\n//         </div>\n//       ))}\n//       <h2>선택한 옵션:</h2>\n//       {selectedOptions.map((selectedOption, index) => (\n//         <p key={index}>\n//           {groupList[index].title}: {selectedOption ? selectedOption.label : '-'}\n//         </p>\n//       ))}\n//     </div>\n//   );\n// };\n//\n// export default App;\n\n\n\n\n// 첫번째 셀렉터에는 적용이 된 상태.\n// import React, { useState, useEffect } from 'react';\n// import Select from 'react-select';\n// import groupListData from './groupListData'; // 정적 데이터 파일 import\n//\n// const App = () => {\n//   const [selectedOptions, setSelectedOptions] = useState([]);\n//   const [isGroupEnabled, setIsGroupEnabled] = useState(Array(groupListData.groupList.length).fill(false));\n//   const [optionList, setOptionList] = useState([]);\n//\n//   // 정적 데이터로서의 품목 그룹 리스트\n//   const groupList = groupListData.groupList;\n//   const countList = groupListData.countList;\n//\n//   // 각 그룹의 옵션을 선택할 때 처리 함수\n//   const handleGroupChange = (selectedOption, groupIndex) => {\n//     const updatedOptions = [...selectedOptions];\n//     updatedOptions[groupIndex] = selectedOption;\n//     setSelectedOptions(updatedOptions);\n//\n//     // 현재 그룹 다음의 그룹을 enable\n//     if (groupIndex < groupList.length - 1) {\n//       const updatedIsGroupEnabled = [...isGroupEnabled];\n//       updatedIsGroupEnabled[groupIndex + 1] = true;\n//       setIsGroupEnabled(updatedIsGroupEnabled);\n//     }\n//   };\n//\n//   // 초기화 시 첫 번째 그룹만 enable\n//   useEffect(() => {\n//     setIsGroupEnabled(updatedIsGroupEnabled => {\n//       const updated = [...updatedIsGroupEnabled];\n//       updated[0] = true;\n//       return updated;\n//     });\n//   }, []);\n//\n//   // 각 셀렉터의 옵션 설정\n//   useEffect(() => {\n//     const updatedOptionList = groupList.map((group, index) => {\n//       if (index === 0) {\n//         return [{\n//           value: group.title,\n//           label: group.title,\n//           isDisabled: true // 처음에는 선택할 수 없도록 disable 처리\n//         }, ...group.options.map(option => ({\n//           value: option,\n//           label: option,\n//           isDisabled: false\n//         }))];\n//       } else {\n//         const previousSelectedOption = selectedOptions[index - 1];\n//         if (previousSelectedOption) {\n//           // 중복된 조합을 필터링하여 하나의 옵션으로만 표시\n//           const currentGroupOptions = [];\n//           const seen = new Set();\n//           countList.forEach(item => {\n//             if (item.combination[index] && item.combination[index - 1] === previousSelectedOption.value && !seen.has(item.combination[index])) {\n//               const label = item.remainCount === 0 ? `${item.combination[index]} (품절)` : `${item.combination[index]} (${item.remainCount} 개 남음)`;\n//               currentGroupOptions.push({\n//                 value: item.combination[index],\n//                 label: label,\n//                 isDisabled: item.remainCount === 0\n//               });\n//               seen.add(item.combination[index]);\n//             }\n//           });\n//           return currentGroupOptions;\n//         } else {\n//           return [];\n//         }\n//       }\n//     });\n//\n//     // 마지막 셀렉터의 모든 옵션을 선택 가능하도록 설정\n//     updatedOptionList[groupList.length - 1] = groupList[groupList.length - 1].options.map(option => ({\n//       value: option,\n//       label: option,\n//       isDisabled: false\n//     }));\n//\n//     setOptionList(updatedOptionList);\n//   }, [countList, groupList, selectedOptions]);\n//\n//   return (\n//     <div>\n//       {groupList.map((group, index) => (\n//         <div key={index}>\n//           <h2>{group.title}</h2>\n//           <Select\n//             options={optionList[index]}\n//             onChange={(selectedOption) => handleGroupChange(selectedOption, index)}\n//             value={selectedOptions[index]}\n//             placeholder={group.title}\n//             isDisabled={index === 0 ? false : !isGroupEnabled[index]} // 첫 번째 셀렉터는 선택할 수 없도록 처리\n//           />\n//         </div>\n//       ))}\n//       <h2>선택한 옵션:</h2>\n//       {selectedOptions.map((selectedOption, index) => (\n//         <p key={index}>\n//           {groupList[index].title}: {selectedOption ? selectedOption.label : '-'}\n//         </p>\n//       ))}\n//     </div>\n//   );\n// };\n//\n// export default App;\n\n//순수리엑트로만 셀렉트 박스 만들기\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}